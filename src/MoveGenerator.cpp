#include "MoveGenerator.hpp"

#include <bitset>

MoveGenerator::MoveGenerator() {}

MoveGenerator::~MoveGenerator() {}

std::list<Move> MoveGenerator::generateMoves(Board board) {
    for (char i = 0; i < 64; ++i) {
        if (board.pieces[i] == Piece::EMPTY) {
            continue;
        }
        if (((board.pieces[i] & Piece::WHITE) == Piece::WHITE) !=
            board.whiteActive) {
            continue;
        }
        std::list<Move> moves;
        switch (board.pieces[i] & Piece::PIECE_MASK) {
            case Piece::PAWN:
                // appends the list of moves generated by generatePawnMoves
                moves.splice(moves.end(), generatePawnMoves(board, i));
                break;
            // case Piece::KNIGHT:
            //     return generateKnightMoves(board, i);
            //     break;
            // case Piece::BISHOP:
            //     return generateDiagonalMoves(board, i);
            //     break;
            // case Piece::ROOK:
            //     return generateStraightMoves(board, i);
            // case Piece::QUEEN: {
            //     moves.splice(moves.end(), generateDiagonalMoves(board, i));
            //     moves.splice(moves.end(), generateStraightMoves(board, i));
            //     break
            // }
            // case Piece::KING:
            //     return generateKingMoves(board, i);
            default:
                break;
        }
    }
    std::list<Move> moves;
    return moves;
}

std::list<Move> MoveGenerator::generatePawnMoves(Board board, char square) {
    char piece = board.pieces[square];
    std::list<Move> moves;
    // White pawn
    bool white = piece & Piece::WHITE;

    int direction = white ? 1 : -1;
    // check one square infront of the pawn
    int targetSquare = square + 8 * direction;
    if (board.pieces[targetSquare] == Piece::EMPTY) {
        Move move = Move(square, targetSquare);
        moves.push_back(move);
        // if pawn is white and on rank 2 or black and on rank 7
        // they can move two squares
        int bigPawnRank = white ? 1 : 6;
        // checks for the rank since
        // if you divide by 8 you get the rank
        if ((square / 8) == bigPawnRank &&
            board.pieces[targetSquare] == Piece::EMPTY) {
            // two square jump
            targetSquare = square + 16 * direction;
            Move move = Move(square, targetSquare);
            moves.push_back(move);
        }
    }
    std::cout << "Generated " << moves.size() << " moves for pawn at square "
              << Board::fieldToString(square) << std::endl;
    return moves;
}